*************************************
//Some C++ Findings and STL common usage
---------------------------------------------------------------------------------------------------------------------------------
1. //Sort vector descending order
// sort(rbegin(vec), rend(vec)); //quite slow
sort(begin(vec), end(vec), greater<T>());
---------------------------------------------------------------------------------------------------------------------------------
1.1* //Not advised but for single programs to include all libs and using single namespace
#include <bits/stdc++.h>
using namespace std;
---------------------------------------------------------------------------------------------------------------------------------
2. //assigns s with n repetitions of myChar (usage of string constructor)
string s = string(n, myChar);
---------------------------------------------------------------------------------------------------------------------------------
3. //Clear of LSB 'set' bit (bit masking)
int x = 436; //110110100
x &= (x-1);  //x = x & (x-1);  //--> now x = 110110000 =  decimal 432
---------------------------------------------------------------------------------------------------------------------------------
4. //C : Using memset to set all 2-d array elements to 0
int arr[m][n];
memset(arr, 0, sizeof(arr));
---------------------------------------------------------------------------------------------------------------------------------
5. //To count number of set bits in given number
__builtin_popcount(n);
---------------------------------------------------------------------------------------------------------------------------------
6. //stable_sort custom comparator
stable_sort( v.begin(), v.end(), []
(const string &s1, const string &s2){
        return s1.size() < s2.size();
});
---------------------------------------------------------------------------------------------------------------------------------
7. //partial sort with custom comparator (K closest points)
vector<vector<int>> kClosest(vector<vector<int>>& ps, int K)
{
  partial_sort(begin(ps), begin(ps) + K, end(ps), [](vector<int> &a, vector<int> &b) {
      return a[0]*a[0]+a[1]*a[1] < b[0]*b[0]+b[1]*b[1];
  });
  ps.resize(K);
  return ps;
}
---------------------------------------------------------------------------------------------------------------------------------
8. //n_th element
REFER = https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/538/week-5-may-29th-may-31st/3345/discuss/217966/C++-3-lines-nth_element-O(n)
std::nth_element() is an STL algorithm
which rearranges the list in such a way such that
the element at the nth position is the one which should be
at that position if we sort the list.
---------------------------------------------------------------------------------------------------------------------------------
9. //adding elements of a vector to an unordered set
std::vector<int> v;
std::unordered_set<int> s(v.begin(), v.end());
---------------------------------------------------------------------------------------------------------------------------------
10. //comparisons of sorts
std::nth_element -> uses modified Quickselect, which provides O(N) complexity regardless of M.

std::partial_sort -> uses Heapselect, which provides better performance than Quickselect for small M.
As a side effect, the end state of Heapselect leaves you with a heap, which means that you get the first half of the Heapsort algorithm "for free".

std::partial_sort is optimized for the case where M is a small constant relative to N.
For example, taking the top 10 items from a very large variable-length list. It is not optimized for the other cases.

In a race between std::partial_sort and std::nth_element + std::sort, std::partial_sort
jumps out to an early lead (small M) but is overtaken by std::nth_element + std::sort once M is no longer small.
---------------------------------------------------------------------------------------------------------------------------------
11. //NOTE : STACK and ARRAY in STL does NOT have .clear() method.
---------------------------------------------------------------------------------------------------------------------------------
12. //upper_bound (OlogN): returns an iterator pointing to the first element in the range [first, last)
//that is greater than value, or last if no such element is found.
//For Example:
unordered_map<int,map<int,int> ump;
auto it = ump[index].upper_bound(value);
it--;
return it->second;
//Example 2:
std::vector<int> v;
v.upper_bound(v.begin(), v.end(), value)
---------------------------------------------------------------------------------------------------------------------------------
13. fatal error: expected parameter declarator
private:
    vector<bool> visited(100, false);
//not allowed             ^
//It should rather be:
vector<bool> visited = std::vector(100,false);
---------------------------------------------------------------------------------------------------------------------------------
14. //In case, you want to print false instead of 0,then you have to sets the boolalpha format flag for the str stream.
std::cout << std::boolalpha << false << std::endl;
---------------------------------------------------------------------------------------------------------------------------------
15. //To print a variable's type in standard C++
#include <typeinfo>
std::cout << typeid(a).name() << '\n';
/*
You might have to activate RTTI in your compiler options for this to work. Additionally, the output of this depends on the compiler.
It might be a raw type name or a name mangling symbol or anything in between.
https://stackoverflow.com/questions/81870/is-it-possible-to-print-a-variables-type-in-standard-c*/
---------------------------------------------------------------------------------------------------------------------------------
16. /* BFS Template */
int level = START; //0 or 1 or whatever
q.push(initial_node);
while(!q.empty())
{
    int sz = q.size();
    while(sz>0)
    {
        //computation and logics add to queue
        //add to visited array/vector
        sz--;
    }
    ++level;
}
return level;
---------------------------------------------------------------------------------------------------------------------------------
17. //To insert a vector into a 2-D vector; //Eg: Pascal Triangle
vector<vector<int>> ps(rowIndex+1);
for(int i=0; i<=rowIndex; ++i)
{
    vector<int> v(i+1, 1);
    ps[i].insert(ps[i].end(), v.begin(), v.end());
    // ps[i].insert(v.begin(), v.end());  //WRONG BECAUSE INSERT POS required : ps[i].end();
}
---------------------------------------------------------------------------------------------------------------------------------
18. // FastIO in C++
static auto fastio = [](){
  // turn off sync
    std::ios::sync_with_stdio(false);
  // untie in/out streams
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    return nullptr;
}();
---------------------------------------------------------------------------------------------------------------------------------
19. //MODULUS : To get a%k where a->negative and k->positive wi
((arr[i] % k)+k)%k
---------------------------------------------------------------------------------------------------------------------------------
20. //Trie class for small alphas nodes_left_in_next_layerclass Trie
{
	public:
    Trie* children[26];
    bool endOfWord;

    Trie()
    {
        endOfWord = false;
        for (int i = 0; i < 26; ++i)
        	children[i] = nullptr;
    }

    ~Trie()
    {
        for (int i = 0; i < 26; ++i)
        	if(children[i]) delete children[i];
    }

    void insert(string s)
    {
      Trie* currNode = this;
      for(char c : s)
      {
        if(!currNode->children[c-'a'])
          currNode->children[c-'a'] = new Trie();
        currNode = currNode->children[c-'a'];
      }
      currNode->endOfWord = true;
    }

    bool search(string word)
    {
        Trie* curr = this;
        for(char c : word)
        {
            curr = curr->children[c-'a'];
            if(!curr)
                return false;
        }
        if(curr->isEndOfWord)
            return true;
        return false;
    }
};
---------------------------------------------------------------------------------------------------------------------------------
21. //Set vs. unordered set and why I can use set<vector<int>> but not unordered_set<vector<int>>

refer : https://stackoverflow.com/a/52203931/7734112

The reason why vector<int> can be as key in set because vector override operator<.
But if you use unordered_set<vector<int>> you have to create a hash function for vector<int>,
because vector does't have a hash function.

//consider
struct VectorHash {
    size_t operator()(const std::vector<int>& v) const {
        std::hash<int> hasher;
        size_t seed = 0;
        for (int i : v) {
            seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);
        }
        return seed;
    }
};

vector<vector<int>> two(){
    //unordered_set<vector<int>> s; // error vector<int> doesn't  have hash function
    unordered_set<vector<int>, VectorHash> s;
    s.insert({1, 2});
    s.insert({1, 3});
    s.insert({1, 2});

    for(const auto& vec:s)
        cout<<vec<<endl;
    // 1 2
    // 1 3
}
---------------------------------------------------------------------------------------------------------------------------------
22. //priority_queue
auto myComp = [](const pair<int, int>& A, const pair<int, int>& B){
    return A.second > B.second;
};
priority_queue<pair<int, double>, vector<pair<int, double>> ,decltype(myComp)> pq(myComp); //either only first arg or 1,2,3 can't do only arg 1 and 3
//or priority_queue<pair<double, int>> pq ;

---------------------------------------------------------------------------------------------------------------------------------
23. //ordered set -> to have random access in a set; [can find kth smallest element in set in O(LogN)]
https://www.geeksforgeeks.org/ordered-set-gnu-c-pbds/#:~:text=About%20ordered%20set,in%20log(n)%20complexity%20.

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

#define oset tree<int, null_type, less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update>
oset s;
//to find kth smallest element
k-=1;
*(s.find_by_order(k));

//funtions of osets:
A. find_by_order : It returns to an iterator to the kth element (counting from zero) in the set in O(logn) time.To find the first element k must be zero.
B. order_of_key  : It returns to the number of items that are strictly smaller than our item k in O(logN) time.
---------------------------------------------------------------------------------------------------------------------------------
24. // how to know if directed graph is ACYCLIC?

A.) DFS on the graph and maintain states :
    -1 = node's children being visited
    0  = node not visited
    1  = node visited
if a node is encountered in DFS with state -1 means it has a back edge and thus a cycle.

B.) Tarjans Strongly Connected components algorithm
---------------------------------------------------------------------------------------------------------------------------------
25. //is string contain any ASCII character, how to create hashmap
vector<int> hash(128, 0);
//to assign count of encountered char in string
hash[(int)s[i]] = 1;  //note : (int) conversion used to get ascii - index
---------------------------------------------------------------------------------------------------------------------------------
26. //convert a string to lower case:
transform(s.begin(), s.end(), s.begin(), ::tolower);
---------------------------------------------------------------------------------------------------------------------------------
27. //Binary search rule of thumb (Not to be followed religiously)
As a rule of thumb, use m = l + (r-l)/2 with l = m + 1 and r = m, and use
m = r - (r-l)/2 with l = m and r = m - 1. This can prevent m from getting stuck at r (or l) after the updating step.
---------------------------------------------------------------------------------------------------------------------------------
28. //Basic Union-Find
class Solution
{
public:
    vector<int> parent,Rank,count,groupCounts;	//Basic union find related storages (groupCounts stores # of groups of size `i`- our reverse mapping)
    int Find(int x)
    {
        return parent[x]==x?x:parent[x]=Find(parent[x]);
    }
    void Union(int x,int y)			//Modified union to update groupCounts
    {
        int xset=Find(x),yset=Find(y);
        if(xset!=yset)
        {
            groupCounts[count[xset]]--,groupCounts[count[yset]]--;//Union'ing would change the groupSize of current x and y groups.
            count[xset]=count[yset]=count[xset]+count[yset];		//Size of groups of x and y now are now size(x)+size(y)
            groupCounts[count[xset]]++;
            Rank[xset]<Rank[yset]?parent[xset]=yset:parent[yset]=xset;
            if(Rank[xset]==Rank[yset])
                Rank[xset]++;
        }
    }
    int findLatestStep(vector<int>& arr, int m)
    {
        parent.resize(arr.size()+1),Rank.resize(arr.size()+1,0);			//Few lines for basic initialization.
        for(int i=1;i<=arr.size();i++)
            parent[i]=i;
        vector<bool> visited(arr.size()+1,false);
        count.resize(arr.size()+1,1);			//Currently all groups are of size 1
        groupCounts.resize(arr.size()+1,0);
        int last=-1,step=1;						//Last stores the result, step is the current step (We can move this to a for loop)
        for(int &i:arr)
        {
            groupCounts[1]++;					//We always chose a new number whose current groupSize is 1 so we increase the groupCount[1] (Reverse Map)
            if(i+1<=arr.size()&&visited[i+1])	//Union i and i+1 if i+1'th bit was previously set
                Union(i,i+1);
            if(i-1>0&&visited[i-1])				//Union i and i-1 if i-1'th bit was previously set
                Union(i,i-1);
            visited[i]=true;
            if(groupCounts[m])					//If counts of group of size m is > 0 (This means we have a group of size m at current step, update `last`)
                last=step;
            step++;
        }
        return last;
    }
};
---------------------------------------------------------------------------------------------------------------------------------
29. //2-D vector
// Create a vector containing n vectors of size m.
    vector<vector<int> > vec( n , vector<int> (m, 0));
---------------------------------------------------------------------------------------------------------------------------------
30. //to increment an array in various intervals list of queries
//Given an array containing n integers and a value 1. m queries are given.
//Each query has two values start and end. For each query, the problem is to increment the values from the start to end index
//in the given array by the given value d.

for(auto intv : req)  //where v = [interval_start, interval_end]
{
    arr[intv[0]] += d;
    if(intv[1]+d < vec.size())
        arr[intv[1]+d] -= 1;
}
--------------------------------------------------------------------------------
31. //comparator inside a class using bool operator()

-----> OR you can simply make a static compare function inside the class say :
NOTE : static is IMPORTANT

******* static bool compare(string a, string b){return a>b} ************

------> OR-------
class Solution
{
public:
    string find(vector<int>& nums)
    {
      vector<string> arr;
      sort(arr.begin(), arr.end(), compare());
    }

private:
  struct compare
  {
    bool operator () (string a, string b)
    {
      string c = a + b;
      string d = b + a;
      return c > d;
    }
  }; //end of struct
};//end of class solution
--------------------------------------------------------------------------------
32. //remove duplicates in vector

v.erase(unique(v.begin(), v.end()), v.end());
--------------------------------------------------------------------------------
33. //ONION-PEEL ALGORITHM
class Solution
{
public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges)
    {
        if(n==0)
            return {};
        if(n==1)
            return {0};
        vector<int>res;
        vector<int>degrees(n,0);
        vector<vector<int>>adj(n);
        for(int i=0;i<edges.size();i++)
        {
            adj[edges[i][0]].push_back(edges[i][1]);//creating adjacent list
            adj[edges[i][1]].push_back(edges[i][0]);
            degrees[edges[i][1]]++;//updating how many edges each node has
            degrees[edges[i][0]]++;
        }
        queue<int>queue;
        for(int i=0; i<n; i++)
        {
            if(degrees[i]==1)//adding all the leave nodes
                queue.push(i);
        }
        while(!queue.empty())
        {
            res.clear();// clear vector before we start traversing level by level.
            int size=queue.size();
            for(int i=0;i<size;i++)
            {
                int cur=queue.front();
                queue.pop();
                //adding nodes to vector.Goal is to get a vector of  just 1 or 2 nodes available.
                res.push_back(cur);
                for(auto &neighbor:adj[cur])
                {
                    degrees[neighbor]--;//removing current leave nodes
                    if(degrees[neighbor]==1)//adding current leave nodes
                        queue.push(neighbor);
                }
            }
        }
        return res;
    }
};
--------------------------------------------------------------------------------
34. //How to remove element not at top from priority_queue?

The best solution is to use std::set. Sets provide methods which allow it to be used both as a min/max heap (or a priority queue).

std::set<int> pq;

//accessing the smallest element(use as min heap)
*pq.begin();

//accessing the largest element (use as max heap)
*pq.rbegin();
Furthermore sets also allow random deletion.

//to delete the integer '6'
auto it = pq.find(6);
pq.erase(it);
--------------------------------------------------------------------------------
35. //Diagonal traversal of 2-D vector
vector<vector<int>> m(n, vector<int>(n,0));
for(int diag = 1; diag < n; ++diag)
{
    for(int i=0; i+diag < n; ++i)
    {
        m[i][i+diag] = //assign value;
    }
}
--------------------------------------------------------------------------------
36. // Count number of 1s in a number
__builtin_popcount = int
__builtin_popcountl = long int
__builtin_popcountll = long long
--------------------------------------------------------------------------------
37. //How to tokenize a string into vector based on a delimiter say "/"
vector<string> FunctionToTokenize(string path) 
{
    // Vector of string to save tokens 
    vector <string> tokens; 

   // stringstream class F 
   stringstream F(path); 
   string intermediate; 

    // Tokenizing w.r.t. space '/' 
    while(getline(F, intermediate, '/')) 
        tokens.push_back(intermediate); 
    return tokens;
}
