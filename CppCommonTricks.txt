*************************************
//Some C++ Findings and STL common usage
---------------------------------------------------------------------------------------------------------------------------------
1. //Sort vector descending order
// sort(rbegin(vec), rend(vec)); //quite slow
sort(begin(vec), end(vec), greater<T>());
---------------------------------------------------------------------------------------------------------------------------------
1.1* //Not advised but for single programs to include all libs and using single namespace
#include <bits/stdc++.h>
using namespace std;
---------------------------------------------------------------------------------------------------------------------------------
2. //assigns s with n repetitions of myChar (usage of string constructor)
string s = string(n, myChar);
---------------------------------------------------------------------------------------------------------------------------------
3. //Clear of LSB 'set' bit (bit masking)
int x = 436; //110110100
x &= (x-1);  //x = x & (x-1);  //--> now x = 110110000 =  decimal 432
---------------------------------------------------------------------------------------------------------------------------------
4. //C : Using memset to set all 2-d array elements to 0
int arr[m][n];
memset(arr, 0, sizeof(arr));
---------------------------------------------------------------------------------------------------------------------------------
5. //To count number of set bits in given number
__builtin_popcount(n);
---------------------------------------------------------------------------------------------------------------------------------
6. //stable_sort custom comparator
stable_sort( v.begin(), v.end(), []
(const string &s1, const string &s2){
        return s1.size() < s2.size();
});
---------------------------------------------------------------------------------------------------------------------------------
7. //partial sort with custom comparator (K closest points)
vector<vector<int>> kClosest(vector<vector<int>>& ps, int K)
{
  partial_sort(begin(ps), begin(ps) + K, end(ps), [](vector<int> &a, vector<int> &b) {
      return a[0]*a[0]+a[1]*a[1] < b[0]*b[0]+b[1]*b[1];
  });
  ps.resize(K);
  return ps;
}
---------------------------------------------------------------------------------------------------------------------------------
8. //n_th element
REFER = https://leetcode.com/explore/challenge/card/may-leetcoding-challenge/538/week-5-may-29th-may-31st/3345/discuss/217966/C++-3-lines-nth_element-O(n)
std::nth_element() is an STL algorithm
which rearranges the list in such a way such that
the element at the nth position is the one which should be
at that position if we sort the list.
---------------------------------------------------------------------------------------------------------------------------------
9. //adding elements of a vector to an unordered set
std::vector<int> v;
std::unordered_set<int> s(v.begin(), v.end());
---------------------------------------------------------------------------------------------------------------------------------
10. //comparisons of sorts
std::nth_element -> uses modified Quickselect, which provides O(N) complexity regardless of M.

std::partial_sort -> uses Heapselect, which provides better performance than Quickselect for small M.
As a side effect, the end state of Heapselect leaves you with a heap, which means that you get the first half of the Heapsort algorithm "for free".

std::partial_sort is optimized for the case where M is a small constant relative to N.
For example, taking the top 10 items from a very large variable-length list. It is not optimized for the other cases.

In a race between std::partial_sort and std::nth_element + std::sort, std::partial_sort
jumps out to an early lead (small M) but is overtaken by std::nth_element + std::sort once M is no longer small.
---------------------------------------------------------------------------------------------------------------------------------
11. //NOTE : STACK and ARRAY in STL does NOT have .clear() method.
---------------------------------------------------------------------------------------------------------------------------------
12. //upper_bound (OlogN): returns an iterator pointing to the first element in the range [first, last)
//that is greater than value, or last if no such element is found.
//For Example:
unordered_map<int,map<int,int> ump;
auto it = ump[index].upper_bound(value);
it--;
return it->second;
//Example 2:
std::vector<int> v;
v.upper_bound(v.begin(), v.end(), value)
---------------------------------------------------------------------------------------------------------------------------------
13. fatal error: expected parameter declarator
private:
    vector<bool> visited(100, false);
//not allowed             ^
//It should rather be:
vector<bool> visited = std::vector(100,false);
---------------------------------------------------------------------------------------------------------------------------------
14. //In case, you want to print false instead of 0,then you have to sets the boolalpha format flag for the str stream.
std::cout << std::boolalpha << false << std::endl;
---------------------------------------------------------------------------------------------------------------------------------
15. //To print a variable's type in standard C++
#include <typeinfo>
std::cout << typeid(a).name() << '\n';
/*
You might have to activate RTTI in your compiler options for this to work. Additionally, the output of this depends on the compiler.
It might be a raw type name or a name mangling symbol or anything in between.
https://stackoverflow.com/questions/81870/is-it-possible-to-print-a-variables-type-in-standard-c*/
---------------------------------------------------------------------------------------------------------------------------------
16. /* BFS Template */
int level = START; //0 or 1 or whatever
q.push(initial_node);
while(!q.empty())
{
    int sz = q.size();
    while(sz>0)
    {
        //computation and logics add to queue
        //add to visited array/vector
        sz--;
    }
    ++level;
}
return level;
---------------------------------------------------------------------------------------------------------------------------------
17. //To insert a vector into a 2-D vector; //Eg: Pascal Triangle
vector<vector<int>> ps(rowIndex+1);
for(int i=0; i<=rowIndex; ++i)
{
    vector<int> v(i+1, 1);
    ps[i].insert(ps[i].end(), v.begin(), v.end());
    // ps[i].insert(v.begin(), v.end());  //WRONG BECAUSE INSERT POS required : ps[i].end();
}
---------------------------------------------------------------------------------------------------------------------------------
18. // FastIO in C++
static auto fastio = [](){
  // turn off sync
    std::ios::sync_with_stdio(false);
  // untie in/out streams
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    return nullptr;
}();
---------------------------------------------------------------------------------------------------------------------------------
19. //MODULUS : To get a%k where a->negative and k->positive wi
((arr[i] % k)+k)%k
---------------------------------------------------------------------------------------------------------------------------------
20. //Trie class for small alphas nodes_left_in_next_layerclass Trie
class Trie{
	public:
    Trie* children[26];
    bool endOfWord;

    Trie()
    {
        endOfWord = false;
        for (int i = 0; i < 26; ++i)
        	children[i] = nullptr;
    }

    ~Trie()
    {
        for (int i = 0; i < 26; ++i)
        	if(children[i]) delete children[i];
    }

    void insert(string s)
    {
      Trie* currNode = this;
      for(char c : s)
      {
        if(!currNode->children[c-'a'])
          currNode->children[c-'a'] = new Trie();
        currNode = currNode->children[c-'a'];
      }
      currNode->endOfWord = true;
    }

    bool search(string word)
    {
        Trie* curr = this;
        for(char c : word)
        {
            curr = curr->children[c-'a'];
            if(!curr)
                return false;
        }
        if(curr->isEndOfWord)
            return true;
        return false;
    }
};
---------------------------------------------------------------------------------------------------------------------------------
21. //Set vs. unordered set and why I can use set<vector<int>> but not unordered_set<vector<int>>

refer : https://stackoverflow.com/a/52203931/7734112

The reason why vector<int> can be as key in set because vector override operator<.
But if you use unordered_set<vector<int>> you have to create a hash function for vector<int>,
because vector does't have a hash function.

//consider
struct VectorHash {
    size_t operator()(const std::vector<int>& v) const {
        std::hash<int> hasher;
        size_t seed = 0;
        for (int i : v) {
            seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);
        }
        return seed;
    }
};

vector<vector<int>> two(){
    //unordered_set<vector<int>> s; // error vector<int> doesn't  have hash function
    unordered_set<vector<int>, VectorHash> s;
    s.insert({1, 2});
    s.insert({1, 3});
    s.insert({1, 2});

    for(const auto& vec:s)
        cout<<vec<<endl;
    // 1 2
    // 1 3
}
---------------------------------------------------------------------------------------------------------------------------------
22. //priority_queue
auto myComp = [](const pair<int, double>& A, const pair<int, double>& B){
    return A.second > B.second;
};
priority_queue<pair<int, double>, vector<pair<int, double>> ,decltype(myComp)> pq(myComp); //either only first arg or 1,2,3 can't do only arg 1 and 3
//or priority_queue<pair<double, int>> pq ;

---------------------------------------------------------------------------------------------------------------------------------
23. //ordered set -> to have random access in a set; [can find kth smallest element in set in O(LogN)]
https://www.geeksforgeeks.org/ordered-set-gnu-c-pbds/#:~:text=About%20ordered%20set,in%20log(n)%20complexity%20.

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

#define oset tree<int, null_type, less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update>
oset s;
//to find kth smallest element
k-=1;
*(s.find_by_order(k));

//funtions of osets:
A. find_by_order : It returns to an iterator to the kth element (counting from zero) in the set in O(logn) time.To find the first element k must be zero.
B. order_of_key  : It returns to the number of items that are strictly smaller than our item k in O(logN) time.
---------------------------------------------------------------------------------------------------------------------------------
24. // how to know if directed graph is ACYCLIC?

A.) DFS on the graph and maintain states :
    -1 = node's children being visited
    0  = node not visited
    1  = node visited
if a node is encountered in DFS with state -1 means it has a back edge and thus a cycle.

B.) Tarjans Strongly Connected components algorithm
---------------------------------------------------------------------------------------------------------------------------------
25. //is string contain any ASCII character, how to create hashmap
vector<int> hash(128, 0);
//to assign count of encountered char in string
hash[(int)s[i]] = 1;  //note : (int) conversion used to get ascii - index
---------------------------------------------------------------------------------------------------------------------------------
26. //convert a string to lower case:
transform(s.begin(), s.end(), s.begin(), ::tolower);
---------------------------------------------------------------------------------------------------------------------------------
27. //Binary search rule of thumb (Not to be followed religiously)
As a rule of thumb, use m = l + (r-l)/2 with l = m + 1 and r = m, and use
m = r - (r-l)/2 with l = m and r = m - 1. This can prevent m from getting stuck at r (or l) after the updating step.
---------------------------------------------------------------------------------------------------------------------------------
28. //Basic Union-Find
class Solution
{
public:
    vector<int> parent,Rank,count,groupCounts;	//Basic union find related storages (groupCounts stores # of groups of size `i`- our reverse mapping)
    int Find(int x)
    {
        return parent[x]==x?x:parent[x]=Find(parent[x]);
    }
    void Union(int x,int y)			//Modified union to update groupCounts
    {
        int xset=Find(x),yset=Find(y);
        if(xset!=yset)
        {
            groupCounts[count[xset]]--,groupCounts[count[yset]]--;//Union'ing would change the groupSize of current x and y groups.
            count[xset]=count[yset]=count[xset]+count[yset];		//Size of groups of x and y now are now size(x)+size(y)
            groupCounts[count[xset]]++;
            Rank[xset]<Rank[yset]?parent[xset]=yset:parent[yset]=xset;
            if(Rank[xset]==Rank[yset])
                Rank[xset]++;
        }
    }
    int findLatestStep(vector<int>& arr, int m)
    {
        parent.resize(arr.size()+1),Rank.resize(arr.size()+1,0);			//Few lines for basic initialization.
        for(int i=1;i<=arr.size();i++)
            parent[i]=i;
        vector<bool> visited(arr.size()+1,false);
        count.resize(arr.size()+1,1);			//Currently all groups are of size 1
        groupCounts.resize(arr.size()+1,0);
        int last=-1,step=1;						//Last stores the result, step is the current step (We can move this to a for loop)
        for(int &i:arr)
        {
            groupCounts[1]++;					//We always chose a new number whose current groupSize is 1 so we increase the groupCount[1] (Reverse Map)
            if(i+1<=arr.size()&&visited[i+1])	//Union i and i+1 if i+1'th bit was previously set
                Union(i,i+1);
            if(i-1>0&&visited[i-1])				//Union i and i-1 if i-1'th bit was previously set
                Union(i,i-1);
            visited[i]=true;
            if(groupCounts[m])					//If counts of group of size m is > 0 (This means we have a group of size m at current step, update `last`)
                last=step;
            step++;
        }
        return last;
    }
};
---------------------------------------------------------------------------------------------------------------------------------
28. b.) Union Find (Simplified) : ref -> https://leetcode.com/discuss/general-discussion/1072418/disjoint-set-union-dsuunion-find

NOTE : USED IN MST (MIN SPANNING TREE) || CYCLE DETECTION IN UN-DIRECTED GRAPHS

//find with path compression
int find(int u)
{
    if(u == representative[u])
        return u;
    else
        return representative[u] = find(representative[u]);
        //compression , if = not used then simply do a recursion call then no compression
}

//union with rank
void union(int u, int v)
{
    u = find(u);
    v = find(v);
    if(u == v)
        return;
    else
    {
        if(rank[u] < rank[v])
        {
            representative[u] = v;
            rank[v] += rank[u];
        }
        else
        {
            representative[v] = u;
            rank[u] += rank[v];
        }
    }
}
---------------------------------------------------------------------------------------------------------------------------------
29. //2-D vector
// Create a vector containing n vectors of size m.
    vector<vector<int> > vec( n , vector<int> (m, 0));
---------------------------------------------------------------------------------------------------------------------------------
30. //to increment an array in various intervals list of queries
//Given an array containing n integers and a value 1. m queries are given.
//Each query has two values start and end. For each query, the problem is to increment the values from the start to end index
//in the given array by the given value d.

for(auto intv : req)  //where v = [interval_start, interval_end]
{
    arr[intv[0]] += d;
    if(intv[1]+d < vec.size())
        arr[intv[1]+d] -= 1;
}
--------------------------------------------------------------------------------
31. //comparator inside a class using bool operator()

-----> OR you can simply make a static compare function inside the class say :
NOTE : static is IMPORTANT

******* static bool compare(string a, string b){return a>b} ************

------> OR-------
class Solution
{
public:
    string find(vector<int>& nums)
    {
      vector<string> arr;
      sort(arr.begin(), arr.end(), compare());
    }

private:
  struct compare
  {
    bool operator () (string a, string b)
    {
      string c = a + b;
      string d = b + a;
      return c > d;
    }
  }; //end of struct
};//end of class solution
--------------------------------------------------------------------------------
32. //remove duplicates in vector

v.erase(unique(v.begin(), v.end()), v.end());
--------------------------------------------------------------------------------
33. //ONION-PEEL ALGORITHM
class Solution
{
public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges)
    {
        if(n==0)
            return {};
        if(n==1)
            return {0};
        vector<int>res;
        vector<int>degrees(n,0);
        vector<vector<int>>adj(n);
        for(int i=0;i<edges.size();i++)
        {
            adj[edges[i][0]].push_back(edges[i][1]);//creating adjacent list
            adj[edges[i][1]].push_back(edges[i][0]);
            degrees[edges[i][1]]++;//updating how many edges each node has
            degrees[edges[i][0]]++;
        }
        queue<int>queue;
        for(int i=0; i<n; i++)
        {
            if(degrees[i]==1)//adding all the leave nodes
                queue.push(i);
        }
        while(!queue.empty())
        {
            res.clear();// clear vector before we start traversing level by level.
            int size=queue.size();
            for(int i=0;i<size;i++)
            {
                int cur=queue.front();
                queue.pop();
                //adding nodes to vector.Goal is to get a vector of  just 1 or 2 nodes available.
                res.push_back(cur);
                for(auto &neighbor:adj[cur])
                {
                    degrees[neighbor]--;//removing current leave nodes
                    if(degrees[neighbor]==1)//adding current leave nodes
                        queue.push(neighbor);
                }
            }
        }
        return res;
    }
};
--------------------------------------------------------------------------------
34. //How to remove element not at top from priority_queue?

The best solution is to use std::set. Sets provide methods which allow it to be used both as a min/max heap (or a priority queue).

std::set<int> pq;

//accessing the smallest element(use as min heap)
*pq.begin();

//accessing the largest element (use as max heap)
*pq.rbegin();
Furthermore sets also allow random deletion.

//to delete the integer '6'
auto it = pq.find(6);
pq.erase(it);
--------------------------------------------------------------------------------
35. //Diagonal traversal of 2-D vector
//(Diag 1 = [0,0] -> [n-1,n-1] : Top left to bottom right)
//(Diag 2 = [0,1] -> [n-2,n-1] ) . . . and so on
vector<vector<int>> m(n, vector<int>(n,0));
for(int diag = 1; diag < n; ++diag)
{
    for(int i=0; i+diag < n; ++i)
    {
        m[i][i+diag] = //assign value;
    }
}
--------------------------------------------------------------------------------
36. // Count number of 1s in a number
__builtin_popcount = int
__builtin_popcountl = long int
__builtin_popcountll = long long
--------------------------------------------------------------------------------
37. //How to tokenize a string into vector based on a delimiter say "/"
vector<string> FunctionToTokenize(string path)
{
    // Vector of string to save tokens
    vector <string> tokens;

   // stringstream class F
   stringstream F(path);
   string intermediate;

    // Tokenizing w.r.t. space '/'
    while(getline(F, intermediate, '/'))
        tokens.push_back(intermediate);
    return tokens;
}
--------------------------------------------------------------------------------
38. //iota function
Fills the range [first, last) with sequentially increasing values, starting with value and repetitively evaluating ++value.

vector<int> vec(n);
int val = 0;
iota(begin(vec), end(vec), val);
--------------------------------------------------------------------------------
39. //sort vector of vector based on ith value of each vector
vector<vector<int>> tasks;
sort(begin(tasks), end(tasks), [&](int i, int j){
    return tasks[i][2] < tasks[j][2];
});
--------------------------------------------------------------------------------
40. //Partial_sum C++ STL : numeric header

int myfun(int a , int b)
{
    return (a+ 2*b);
}

partial_sum(a , a+5 , b , myfun);
                      ^ new vector/array same size as a

to calculate prefix sum simply use :

vector<int> b(a.size()+1, 0); //So now to calculate range based sums simply use 1-based indexing on b
partial_sum(begin(a), end(a), b.begin()+1);

--------------------------------------------------------------------------------
41. //KAHN'S ALGORITHM: Simple Topological sort of graph (using queues, BFS) {can also be used in cycle detection}

bool canFinish(int n, vector<pair<int, int>>& pre)
{
    vector<vector<int>> adj(n, vector<int>()); //adjacency list (graph representation)
    vector<int> degree(n, 0); //to calculate in-degree
    for (auto &p: pre) {
        adj[p.second].push_back(p.first); //TAKE CARE OF ORDER HERE pre[i, j] means i <---- j
        degree[p.first]++;
    }

    queue<int> q;
    for (int i = 0; i < n; i++)
        if (degree[i] == 0) q.push(i); //initially insert all nodes with no in-degrees (i.e no incoming directed edge)


    while (!q.empty())
    {
        int curr = q.front();
        q.pop();
        n--; // Since all the elements in queue are without any dependency, decrease the dependency by 1.
        //or just keep a count variable and ++ it here. Finally for returning use =>  return count == n;

        /**
         * Decrease in degree for each dependents coz this course has already been taken.
         *  Decrease no of pre-req by 1. If no pre-req, add it to the queue (as queue represents elements without any pre-req).
         */
        for (auto next: adj[curr])
            if (--degree[next] == 0)
                q.push(next);
    }
    return n == 0;  //or return count == n;
}
--------------------------------------------------------------------------------

42. //DFS Cycle detection (**IN DIRECTED GRAPH**) using graph coloring  where [ 0-> not visited; 1->being_visted; 2-> completed/processed]

bool DFScycle(const vector<vector<int>>& adj, vector<int>& visited, int v)
{
    if(visited[v] == 1)
        return true;  //implies we detected BACK EDGE hence cycle

    /*trying to visit an already processed node so no value in that (because had it contained a cycle it would already been detected)*/
    if(visited[v] == 2)
        return false;

    visited[v] = 1; //mark as currently being visited

    for(int i : adj[v])
        if(DFScycle(adj, visited, i))
            return true;

    visited[v] = 2; //mark node as processed finally
    return false;
}
--------------------------------------------------------------------------------
43. // Modular Exponentiation
#include <iostream>
using namespace std;
#define M 1000000007

// Normal Method Complexity - O(n)
// Complexity - O(logn)
// Modular Exponention
long long int calculatepower(long long int A, long long int B)
{
    if (B == 0)
        return 1;

    else if (B % 2 == 0)
        return calculatepower((A*A) % M, B >> 1) % M;
    else
        return (A * calculatepower((A*A) % M, B >> 1) % M );
}

int main()
{
    cout << calculatepower(2, 10);
    return 0;
}
--------------------------------------------------------------------------------
44.// CP
#define endl "\n"
#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
#define FIO ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define ll long long
#define vi vector<ll>
#define pb push_back
#define F first
#define S second
#define all(v) (v).begin(),(v).end()
#define pii pair<ll,ll>
#define vii vector<pii>
#define vb  vector<bool>
#define vvi vector<vi>
#define vvb vector<vb>
#define calc_fact(n) tgamma(n+1)
#define inf LONG_LONG_MAX
#define MOD 1000000007
#define mod 998244353
--------------------------------------------------------------------------------
45. // SEGMENT TREE
***Ques: Range Sum Query - Mutable

Given an integer array nums, handle multiple queries of the following types:
Update the value of an element in nums.
Calculate the sum of the elements of nums between indices left and right inclusive where left <= right

//Ref : https://www.youtube.com/watch?v=dUkRI0R3sg8&t=10s
class STNode
{
public:
    STNode* left; STNode* right;
    int sum, start, end;

    STNode(int start, int end)
    {
        this->left = NULL;
        this->right = NULL;
        this->sum = 0;
        this->start = start;
        this->end = end;
    }
};

class NumArray
{
public:

    STNode* root = nullptr;

    //TC : O(N)
//-------------BUILD SEGMENT TREE------------------

    STNode* buildTree(vector<int>& nums, int start, int end)
    {
        if(start > end){
            return nullptr;
        }
        else
        {
            //PREODER TRAVERSAL --> **** NODE, LEFT, RIGHT ****
            STNode* ret = new STNode(start, end);  //****NODE****
            if(start == end)
            {
                ret->sum = nums[start]; //LEAF NODES
            }
            else
            {
                int mid = start + (end-start)/2;

                ret->left = buildTree(nums, start, mid);  //****LEFT****
                ret->right = buildTree(nums, mid+1,end); //****RIGHT****

                ret->sum = ret->left->sum + ret->right->sum;
            }

            return ret;
        }
    }
//-------------END OF BUILD SEGMENT TREE------------------



    NumArray(vector<int>& nums) {
        root = buildTree(nums,0, nums.size()-1);
        cout<<"Root sum = "<<root->sum<<endl;
    }

    void updateHelper(STNode* root, int index, int val)
    {
        if(root->start == root->end)
            root->sum = val;

        else
        {
            int mid = root->start + (root->end - root->start)/2;

            if(mid >= index)
                updateHelper(root->left, index, val);
            else
                updateHelper(root->right, index, val);

            root->sum = root->left->sum + root->right->sum;
        }
    }
    void update(int index, int val) {
        updateHelper(root, index, val);
    }


    int sumRange(int left, int right) {
        return sumHelper(root, left, right);
    }

    int sumHelper(STNode* root, int left, int right)
    {
        if(root->start == left && root->end == right)
            return root->sum;
        else
        {
            int mid = root->start + (root->end - root->start)/2;
            if(mid >= right)
                return sumHelper(root->left, left, right);
            else if(mid+1 <= left)
                return sumHelper(root->right, left, right);
            else
                return (sumHelper(root->left, left, mid) + sumHelper(root->right, mid+1, right));
        }
    }
};

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray* obj = new NumArray(nums);
 * obj->update(index,val);
 * int param_2 = obj->sumRange(left,right);
 */
--------------------------------------------------------------------------------

46. //K_SUM

public class Solution {
    int len = 0;
    public List<List<Integer>> fourSum(int[] nums, int target) {
        len = nums.length;
        Arrays.sort(nums);
        return kSum(nums, target, 4, 0);
    }
   private ArrayList<List<Integer>> kSum(int[] nums, int target, int k, int index) {
        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();
        if(index >= len) {
            return res;
        }
        if(k == 2) {
        	int i = index, j = len - 1;
        	while(i < j) {
                //find a pair
        	    if(target - nums[i] == nums[j]) {
        	    	List<Integer> temp = new ArrayList<>();
                	temp.add(nums[i]);
                	temp.add(target-nums[i]);
                    res.add(temp);
                    //skip duplication
                    while(i<j && nums[i]==nums[i+1]) i++;
                    while(i<j && nums[j-1]==nums[j]) j--;
                    i++;
                    j--;
                //move left bound
        	    } else if (target - nums[i] > nums[j]) {
        	        i++;
                //move right bound
        	    } else {
        	        j--;
        	    }
        	}
        } else{
            for (int i = index; i < len - k + 1; i++) {
                //use current number to reduce ksum into k-1sum
                ArrayList<List<Integer>> temp = kSum(nums, target - nums[i], k-1, i+1);
                if(temp != null){
                    //add previous results
                    for (List<Integer> t : temp) {
                        t.add(0, nums[i]);
                    }
                    res.addAll(temp);
                }
                while (i < len-1 && nums[i] == nums[i+1]) {
                    //skip duplicated numbers
                    i++;
                }
            }
        }
        return res;
    }
}

--------------------------------------------------------------------------------
//47. Sscanf() a C function
Say given compex numbers a and b in format (-)real + (-)imaginary i
void getComplex(string a, string b){
    int real_x, img_x, real_y, img_y;
    sscanf(a.c_str(), "%d+%di",&real_x, &img_x);
    sscanf(b.c_str(), "%d+%di",&real_y, &img_y);
}
--------------------------------------------------------------------------------
//48. How to create an unordered_map of pairs in C++?
https://www.geeksforgeeks.org/how-to-create-an-unordered_map-of-pairs-in-c/


// A hash function used to hash a pair of any kind
struct myHashFunc {
	template <class T1, class T2>
	size_t operator()(const pair<T1, T2>& p) const
	{
		auto hash1 = hash<T1>{}(p.first);
		auto hash2 = hash<T2>{}(p.second);
		return hash1 ^ hash2;
	}
};

int main()
{
	// Sending the hash function as a third argument
	unordered_map<pair<int, int>, bool, myHashFunc> um;

}
--------------------------------------------------------------------------------
//49. How to create an unordered_map of user defined class in C++?
https://www.geeksforgeeks.org/how-to-create-an-unordered_map-of-user-defined-class-in-cpp/

// CPP program to demonstrate working of unordered_map
// for user defined data types.
#include <bits/stdc++.h>
using namespace std;

// Objects of this class are used as key in hash table. This class must implement operator ==() to handle collisions.
struct Person {
	string first, last; // First and last names

	Person(string f, string l)
	{
		first = f;
		last = l;
	}

	// Match both first and last names in case
	// of collisions.
	bool operator==(const Person& p) const     //<************* IMPORTANT
	{
		return first == p.first && last == p.last;
	}
};

class MyHashFunction {
public:

	// Use sum of lengths of first and last names as hash function.
	size_t operator()(const Person& p) const    //<************* IMPORTANT
	{
		return p.first.length() + p.last.length();
	}
};

// Driver code
int main()
{
	unordered_map<Person, int, MyHashFunction> um;
	Person p1("bhavuk", "kapoor");
  um[p1] = 100;
}
--------------------------------------------------------------------------------
//50. The list::splice() is a built-in function in C++ STL which is used to transfer
elements from one list to another. The splice() function can be used in three ways:

Transfer all the elements of list x into another list at some position.
Transfer only the element pointed by i from list x into the list at some position.
Transfers the range [first, last) from list x into another list at some position.

list1_name.splice (iterator position, list2)
                or
list1_name.splice (iterator position, list2, iterator i)
                or
list1_name.splice (iterator position, list2, iterator first, iterator last)

Parameters: The function accepts four parameters which are specified as below:

position – Specifies the position where the elements are to be transferred.
list2 – It specifies a list object of the same type which is to be transferred.
i – It specifies an iterator to the position of an element in list2 which is to be transferred.
first, last – Iterators specifying a range of elements in list2 which is to be transferred in list1.
The range includes all the elements between first and last, including the element pointed by first but not the one pointed by last.
--------------------------------------------------------------------------------
//51. making modification on a temporary is meaningless, C++ doesn't want you to bind non-const reference to a temporary. For example:

int a;
double &m = a;  // caution:this does not work.
What if it works?
a is of type int and is being converted to double. So a temporary is created.

You can modify m, which is bound to a temporary, but almost nothing happens. 
After the modification, variable a does not change (what's worse? You might think a has changed, which may cause problems).
--------------------------------------------------------------------------------